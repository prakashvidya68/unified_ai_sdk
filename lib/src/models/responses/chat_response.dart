import '../common/message.dart';
import '../common/usage.dart';

/// Represents a single completion choice in a chat response.
///
/// Most providers return multiple choices when `n > 1` is specified in the request.
/// Each choice contains a [message] (the assistant's response), an [index] (its
/// position in the choices list), and optionally a [finishReason] (why generation stopped).
///
/// **Example usage:**
/// ```dart
/// final choice = ChatChoice(
///   index: 0,
///   message: Message(role: Role.assistant, content: 'Hello!'),
///   finishReason: 'stop',
/// );
/// ```
class ChatChoice {
  /// The index of this choice in the choices array.
  ///
  /// Typically 0 for single completions, but can be 0, 1, 2, etc. when
  /// multiple completions are requested.
  final int index;

  /// The assistant's message in this choice.
  ///
  /// Contains the actual text response from the AI model.
  final Message message;

  /// The reason why the model stopped generating tokens.
  ///
  /// Common values:
  /// - `"stop"`: Model hit a stop sequence or natural stopping point
  /// - `"length"`: Model hit the max_tokens limit
  /// - `"content_filter"`: Content was filtered by safety systems
  /// - `"function_call"`: Model chose to call a function
  /// - `null`: Unknown or not provided by the provider
  final String? finishReason;

  /// Creates a new [ChatChoice] instance.
  ///
  /// [index] and [message] are required. [finishReason] is optional.
  const ChatChoice({
    required this.index,
    required this.message,
    this.finishReason,
  });

  /// Converts this [ChatChoice] to a JSON map.
  ///
  /// The resulting map is compatible with most AI provider APIs.
  Map<String, dynamic> toJson() {
    return {
      'index': index,
      'message': message.toJson(),
      if (finishReason != null) 'finish_reason': finishReason,
    };
  }

  /// Creates a [ChatChoice] instance from a JSON map.
  ///
  /// Parses the JSON representation of a chat choice into a [ChatChoice] object.
  ///
  /// **Example input:**
  /// ```json
  /// {
  ///   "index": 0,
  ///   "message": {
  ///     "role": "assistant",
  ///     "content": "Hello!"
  ///   },
  ///   "finish_reason": "stop"
  /// }
  /// ```
  factory ChatChoice.fromJson(Map<String, dynamic> json) {
    return ChatChoice(
      index: json['index'] as int,
      message: Message.fromJson(json['message'] as Map<String, dynamic>),
      finishReason: json['finish_reason'] as String?,
    );
  }

  /// Creates a copy of this [ChatChoice] with the given fields replaced.
  ChatChoice copyWith({
    int? index,
    Message? message,
    String? finishReason,
  }) {
    return ChatChoice(
      index: index ?? this.index,
      message: message ?? this.message,
      finishReason: finishReason ?? this.finishReason,
    );
  }

  @override
  String toString() {
    return 'ChatChoice(index: $index, message: $message${finishReason != null ? ", finishReason: $finishReason" : ""})';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ChatChoice &&
        other.index == index &&
        other.message == message &&
        other.finishReason == finishReason;
  }

  @override
  int get hashCode {
    return Object.hash(index, message, finishReason);
  }
}

/// Represents a complete chat completion response from an AI provider.
///
/// This is the primary response type returned by [chat()] operations.
/// It contains the generated choices, token usage information, and metadata
/// about the response.
///
/// **Example usage:**
/// ```dart
/// final response = await ai.chat(request: chatRequest);
/// print(response.choices.first.message.content);
/// print('Used ${response.usage.totalTokens} tokens');
/// ```
class ChatResponse {
  /// Unique identifier for this completion response.
  ///
  /// Provided by the AI provider to identify this specific completion.
  /// Useful for logging, debugging, and correlating requests with responses.
  final String id;

  /// List of completion choices generated by the model.
  ///
  /// Typically contains one choice, but can contain multiple when `n > 1`
  /// is specified in the request. Use [choices.first] for the primary response.
  final List<ChatChoice> choices;

  /// Token usage statistics for this completion.
  ///
  /// Contains information about how many tokens were used in the prompt
  /// and completion, useful for cost tracking and monitoring.
  final Usage usage;

  /// The model identifier used for this completion.
  ///
  /// Examples: "gpt-4", "claude-3-opus", "gemini-pro"
  final String model;

  /// The provider that generated this response.
  ///
  /// Examples: "openai", "anthropic", "google"
  final String provider;

  /// Timestamp when this response was created.
  ///
  /// Defaults to the current time if not specified. Useful for tracking
  /// response times and ordering responses.
  final DateTime timestamp;

  /// Optional metadata associated with this response.
  ///
  /// Can contain provider-specific fields, request IDs, or custom metadata
  /// that doesn't fit into the standard response structure.
  final Map<String, dynamic>? metadata;

  /// Creates a new [ChatResponse] instance.
  ///
  /// [id], [choices], [usage], [model], and [provider] are required.
  /// [timestamp] defaults to the current time if not provided.
  /// [metadata] is optional.
  ChatResponse({
    required this.id,
    required this.choices,
    required this.usage,
    required this.model,
    required this.provider,
    DateTime? timestamp,
    this.metadata,
  }) : timestamp = timestamp ?? DateTime.now();

  /// Converts this [ChatResponse] to a JSON map.
  ///
  /// The resulting map includes all response data in a provider-agnostic format.
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'choices': choices.map((c) => c.toJson()).toList(),
      'usage': usage.toJson(),
      'model': model,
      'provider': provider,
      'timestamp': timestamp.toIso8601String(),
      if (metadata != null) 'metadata': metadata,
    };
  }

  /// Creates a [ChatResponse] instance from a JSON map.
  ///
  /// Parses the JSON representation of a chat response into a [ChatResponse] object.
  ///
  /// **Example input:**
  /// ```json
  /// {
  ///   "id": "chatcmpl-123",
  ///   "choices": [{
  ///     "index": 0,
  ///     "message": {"role": "assistant", "content": "Hello!"},
  ///     "finish_reason": "stop"
  ///   }],
  ///   "usage": {
  ///     "prompt_tokens": 10,
  ///     "completion_tokens": 5,
  ///     "total_tokens": 15
  ///   },
  ///   "model": "gpt-4",
  ///   "provider": "openai"
  /// }
  /// ```
  factory ChatResponse.fromJson(Map<String, dynamic> json) {
    return ChatResponse(
      id: json['id'] as String,
      choices: (json['choices'] as List)
          .map((c) => ChatChoice.fromJson(c as Map<String, dynamic>))
          .toList(),
      usage: Usage.fromJson(json['usage'] as Map<String, dynamic>),
      model: json['model'] as String,
      provider: json['provider'] as String,
      timestamp: json['timestamp'] != null
          ? DateTime.parse(json['timestamp'] as String)
          : null,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  /// Creates a copy of this [ChatResponse] with the given fields replaced.
  ChatResponse copyWith({
    String? id,
    List<ChatChoice>? choices,
    Usage? usage,
    String? model,
    String? provider,
    DateTime? timestamp,
    Map<String, dynamic>? metadata,
  }) {
    return ChatResponse(
      id: id ?? this.id,
      choices: choices ?? this.choices,
      usage: usage ?? this.usage,
      model: model ?? this.model,
      provider: provider ?? this.provider,
      timestamp: timestamp ?? this.timestamp,
      metadata: metadata ?? this.metadata,
    );
  }

  @override
  String toString() {
    return 'ChatResponse(id: $id, choices: ${choices.length}, model: $model, provider: $provider, usage: $usage)';
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ChatResponse &&
        other.id == id &&
        _listEquals(other.choices, choices) &&
        other.usage == usage &&
        other.model == model &&
        other.provider == provider &&
        other.timestamp == timestamp &&
        _mapEquals(other.metadata, metadata);
  }

  @override
  int get hashCode {
    return Object.hash(
        id, choices, usage, model, provider, timestamp, metadata);
  }

  /// Helper method to compare lists for equality.
  bool _listEquals<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  /// Helper method to compare maps for equality.
  bool _mapEquals(Map<String, dynamic>? a, Map<String, dynamic>? b) {
    if (a == null && b == null) return true;
    if (a == null || b == null) return false;
    if (a.length != b.length) return false;
    for (final key in a.keys) {
      if (a[key] != b[key]) return false;
    }
    return true;
  }
}
